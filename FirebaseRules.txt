rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthenticated() {
      return request.auth != null;
    }

    function uid() {
      return request.auth.uid;
    }

    function communityData(communityId) {
      return get(/databases/$(database)/documents/communities/$(communityId)).data;
    }

    function isCommunityMember(communityId) {
      return isAuthenticated()
        && (uid() in communityData(communityId).members);
    }

    function isNonEmptyString(x, maxLen) {
      return x is string && x.size() > 0 && x.size() <= maxLen;
    }

    function isStringOrNull(x) {
      return x == null || x is string;
    }

    function keysAreOnly(data, allowed) {
      return data.keys().hasOnly(allowed);
    }

    function changedKeysOnly(allowed) {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(allowed);
    }

    function gameData(gameId) {
      return get(/databases/$(database)/documents/games/$(gameId)).data;
    }

    function isGameParticipant(gameId) {
      return isAuthenticated()
        && (uid() == gameData(gameId).player1Id || uid() == gameData(gameId).player2Id);
    }

    function isTimestampOrServerTime(x) {
      return (x is timestamp) || (x == request.time);
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // COMMUNITIES
    // ─────────────────────────────────────────────────────────────────────────────
    match /communities/{communityId} {

      // READ: Members can read their community.
      // Also allow reading by invite code for join flow (user not yet a member).
      allow read: if isAuthenticated();

      // CREATE: Standard community creation
      allow create: if isAuthenticated()
        && keysAreOnly(request.resource.data, [
          'name',
          'description',
          'createdBy',
          'createdAt',
          'inviteCode',
          'members',
          'isActive'
        ])
        && request.resource.data.createdBy == uid()
        && isNonEmptyString(request.resource.data.name, 80)
        && (request.resource.data.description == null || request.resource.data.description is string)
        && isNonEmptyString(request.resource.data.inviteCode, 12)
        && request.resource.data.members is list
        && request.resource.data.members.size() >= 1
        && request.resource.data.members.size() <= 500
        && (uid() in request.resource.data.members)
        && request.resource.data.isActive is bool
        && isTimestampOrServerTime(request.resource.data.createdAt);

      // UPDATE: Two cases:
      // 1. Creator can update name, description, members, isActive
      // 2. Anyone can add ONLY themselves to members (join flow)
      allow update: if isAuthenticated()
        && (
          // Case 1: Creator can do full updates
          (
            uid() == resource.data.createdBy
            && changedKeysOnly(['name', 'description', 'members', 'isActive'])
            && isNonEmptyString(request.resource.data.name, 80)
            && (request.resource.data.description == null || request.resource.data.description is string)
            && request.resource.data.isActive is bool
          )
          ||
          // Case 2: Anyone can join (add themselves to members only)
          (
            changedKeysOnly(['members'])
            && request.resource.data.members.hasAll(resource.data.members)
            && request.resource.data.members.size() == resource.data.members.size() + 1
            && uid() in request.resource.data.members
            && !(uid() in resource.data.members)
          )
        )
        // Common validations for both cases
        && request.resource.data.members is list
        && request.resource.data.members.size() >= 1
        && request.resource.data.members.size() <= 500
        // Immutable fields
        && request.resource.data.createdBy == resource.data.createdBy
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.inviteCode == resource.data.inviteCode;

      allow delete: if false;
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // GAMES
    // ─────────────────────────────────────────────────────────────────────────────
    match /games/{gameId} {

      function isMockId(x) {
        return x is string && x.matches('^mock_user_.*');
      }

      function bothRevealed(data) {
        return data.player1ActualContact != null && data.player2ActualContact != null;
      }

      allow read: if isAuthenticated()
        && (uid() == resource.data.player1Id || uid() == resource.data.player2Id);

      allow create: if isAuthenticated()
        && keysAreOnly(request.resource.data, [
          'communityId',
          'player1Id',
          'player2Id',
          'status',
          'createdAt',
          'player1Guess',
          'player2Guess',
          'player1GuessSubmittedAt',
          'player2GuessSubmittedAt',
          'player1ActualContact',
          'player2ActualContact',
          'player1RevealedAt',
          'player2RevealedAt',
          'winner',
          'outcome',
          'gameCompletedAt',
          'consequences',
          'consequencesPersisted',
          'isBotOpponent',
          'botOpponent'
        ])
        && request.resource.data.player1Id == uid()
        && request.resource.data.player2Id is string
        && request.resource.data.player2Id != uid()
        && request.resource.data.communityId is string
        && isCommunityMember(request.resource.data.communityId)
        && (request.resource.data.player2Id in communityData(request.resource.data.communityId).members)
        && request.resource.data.status == 'active'
        && isTimestampOrServerTime(request.resource.data.createdAt)
        && request.resource.data.player1Guess == null
        && request.resource.data.player2Guess == null
        && request.resource.data.player1GuessSubmittedAt == null
        && request.resource.data.player2GuessSubmittedAt == null
        && request.resource.data.player1ActualContact == null
        && request.resource.data.player2ActualContact == null
        && request.resource.data.player1RevealedAt == null
        && request.resource.data.player2RevealedAt == null
        && request.resource.data.winner == null
        && request.resource.data.outcome == null
        && request.resource.data.gameCompletedAt == null
        && request.resource.data.consequences is list
        && request.resource.data.consequences.size() == 0
        && (request.resource.data.consequencesPersisted == null || request.resource.data.consequencesPersisted is bool)
        && (request.resource.data.isBotOpponent == null || request.resource.data.isBotOpponent is bool)
        && (request.resource.data.botOpponent == null || request.resource.data.botOpponent is bool);

      allow update: if isAuthenticated()
        && (uid() == resource.data.player1Id || uid() == resource.data.player2Id)
        // Immutable fields
        && request.resource.data.communityId == resource.data.communityId
        && request.resource.data.player1Id == resource.data.player1Id
        && request.resource.data.player2Id == resource.data.player2Id
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.isBotOpponent == resource.data.isBotOpponent
        && request.resource.data.botOpponent == resource.data.botOpponent
        // Only these fields can change
        && changedKeysOnly([
          'player1Guess',
          'player2Guess',
          'player1GuessSubmittedAt',
          'player2GuessSubmittedAt',
          'player1ActualContact',
          'player2ActualContact',
          'player1RevealedAt',
          'player2RevealedAt',
          'status',
          'outcome',
          'winner',
          'gameCompletedAt',
          'consequences',
          'consequencesPersisted'
        ])
        // Type checks
        && isStringOrNull(request.resource.data.player1Guess)
        && isStringOrNull(request.resource.data.player2Guess)
        && (request.resource.data.player1GuessSubmittedAt == null || isTimestampOrServerTime(request.resource.data.player1GuessSubmittedAt))
        && (request.resource.data.player2GuessSubmittedAt == null || isTimestampOrServerTime(request.resource.data.player2GuessSubmittedAt))
        && isStringOrNull(request.resource.data.player1ActualContact)
        && isStringOrNull(request.resource.data.player2ActualContact)
        && (request.resource.data.player1RevealedAt == null || isTimestampOrServerTime(request.resource.data.player1RevealedAt))
        && (request.resource.data.player2RevealedAt == null || isTimestampOrServerTime(request.resource.data.player2RevealedAt))
        && (request.resource.data.gameCompletedAt == null || isTimestampOrServerTime(request.resource.data.gameCompletedAt))
        && (request.resource.data.consequencesPersisted == null || request.resource.data.consequencesPersisted is bool)
        && (request.resource.data.consequences == null || request.resource.data.consequences is list)
        // Prevent overwrites: guesses/reveals can only be set once
        && (resource.data.player1Guess == null || request.resource.data.player1Guess == resource.data.player1Guess)
        && (resource.data.player2Guess == null || request.resource.data.player2Guess == resource.data.player2Guess)
        && (resource.data.player1ActualContact == null || request.resource.data.player1ActualContact == resource.data.player1ActualContact)
        && (resource.data.player2ActualContact == null || request.resource.data.player2ActualContact == resource.data.player2ActualContact)
        // Player field ownership (with mock user exception)
        && (
          // Player1 acting
          (uid() == resource.data.player1Id
            && (
              // Normal: cannot change player2 fields
              (
                !isMockId(resource.data.player2Id)
                && request.resource.data.player2Guess == resource.data.player2Guess
                && request.resource.data.player2GuessSubmittedAt == resource.data.player2GuessSubmittedAt
                && request.resource.data.player2ActualContact == resource.data.player2ActualContact
                && request.resource.data.player2RevealedAt == resource.data.player2RevealedAt
              )
              ||
              // Mock opponent: player1 can control player2 fields
              isMockId(resource.data.player2Id)
            )
          )
          ||
          // Player2 acting
          (uid() == resource.data.player2Id
            && (
              (
                !isMockId(resource.data.player1Id)
                && request.resource.data.player1Guess == resource.data.player1Guess
                && request.resource.data.player1GuessSubmittedAt == resource.data.player1GuessSubmittedAt
                && request.resource.data.player1ActualContact == resource.data.player1ActualContact
                && request.resource.data.player1RevealedAt == resource.data.player1RevealedAt
              )
              ||
              isMockId(resource.data.player1Id)
            )
          )
        )
        // Status transitions
        && request.resource.data.status in ['active', 'guessing_complete', 'completed']
        // Completion requirements
        && (
          request.resource.data.status != 'completed'
          || (
            bothRevealed(request.resource.data)
            && request.resource.data.outcome is string
            && request.resource.data.winner in ['player1', 'player2', 'tie', 'none']
            && isTimestampOrServerTime(request.resource.data.gameCompletedAt)
          )
        );

      allow delete: if false;
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // USERS
    // ─────────────────────────────────────────────────────────────────────────────
    match /users/{userId} {
      allow read: if isAuthenticated() && uid() == userId;
      allow write: if isAuthenticated() && uid() == userId;
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // CONSEQUENCES
    // ─────────────────────────────────────────────────────────────────────────────
    match /consequences/{consequenceId} {

      // Helper to check if user is a game participant
      function isGamePlayer(gId) {
        let g = get(/databases/$(database)/documents/games/$(gId)).data;
        return uid() == g.player1Id || uid() == g.player2Id;
      }

      allow read: if isAuthenticated()
        && (uid() == resource.data.playerId || uid() == resource.data.targetId);

      // CREATE: Any participant of the game can create consequences for that game.
      // This allows batch creation where one player triggers game completion and
      // creates consequences for both players atomically.
      // Note: We don't check gameIsCompleted because batch writes evaluate rules
      // against pre-commit state, and the game status update happens in the same batch.
      allow create: if isAuthenticated()
        && keysAreOnly(request.resource.data, [
          'id',
          'fromGameId',
          'communityId',
          'playerId',
          'targetId',
          'type',
          'description',
          'completed',
          'completedAt',
          'proofText',
          'createdAt'
        ])
        && request.resource.data.id == consequenceId
        && request.resource.data.fromGameId is string
        && request.resource.data.communityId is string
        // Creator must be a participant in the game
        && isGamePlayer(request.resource.data.fromGameId)
        // playerId must be a game participant or mock user
        && (
          request.resource.data.playerId == gameData(request.resource.data.fromGameId).player1Id
          || request.resource.data.playerId == gameData(request.resource.data.fromGameId).player2Id
          || request.resource.data.playerId.matches('^mock_user_.*')
        )
        // targetId must be a community member (includes mock users if they're in the community)
        && (request.resource.data.targetId in communityData(request.resource.data.communityId).members)
        && request.resource.data.type in ['owed', 'joint']
        && isNonEmptyString(request.resource.data.description, 240)
        && request.resource.data.completed == false
        && request.resource.data.completedAt == null
        && (request.resource.data.proofText == null || request.resource.data.proofText is string)
        && isTimestampOrServerTime(request.resource.data.createdAt);

      // UPDATE: Only the playerId can mark their own consequence complete
      allow update: if isAuthenticated()
        && uid() == resource.data.playerId
        && changedKeysOnly(['completed', 'completedAt', 'proofText'])
        && request.resource.data.completed is bool
        && (request.resource.data.completedAt == null || isTimestampOrServerTime(request.resource.data.completedAt))
        && (request.resource.data.proofText == null || request.resource.data.proofText is string);

      allow delete: if false;
    }
  }
}